// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'config.dart';
import 'net_info.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

/// A collection of statistical metrics for a series of latency samples.
class LatencyStats {
  /// The final, representative latency value, typically the mean.
  final BigInt latencyMs;

  /// The standard deviation of the latency samples, representing jitter.
  final BigInt jitterMs;

  /// The percentage of failed samples out of the total expected.
  final double packetLossPercent;

  /// The minimum latency recorded in the sample set.
  final BigInt? minLatencyMs;

  /// The average latency of the sample set.
  final BigInt? avgLatencyMs;

  /// The maximum latency recorded in the sample set.
  final BigInt? maxLatencyMs;

  /// A calculated score from 0-100 representing connection stability,
  /// factoring in jitter, packet loss, and latency spikes.
  final int stabilityScore;

  /// A collection of statistical metrics for a series of latency samples.

  const LatencyStats({
    required this.latencyMs,
    required this.jitterMs,
    required this.packetLossPercent,
    this.minLatencyMs,
    this.avgLatencyMs,
    this.maxLatencyMs,
    required this.stabilityScore,
  });

  @override
  int get hashCode =>
      latencyMs.hashCode ^
      jitterMs.hashCode ^
      packetLossPercent.hashCode ^
      minLatencyMs.hashCode ^
      avgLatencyMs.hashCode ^
      maxLatencyMs.hashCode ^
      stabilityScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LatencyStats &&
          runtimeType == other.runtimeType &&
          latencyMs == other.latencyMs &&
          jitterMs == other.jitterMs &&
          packetLossPercent == other.packetLossPercent &&
          minLatencyMs == other.minLatencyMs &&
          avgLatencyMs == other.avgLatencyMs &&
          maxLatencyMs == other.maxLatencyMs &&
          stabilityScore == other.stabilityScore;
}

/// The top-level report containing all information from a comprehensive network check.
class NetworkReport {
  /// The timestamp (in milliseconds since epoch) when the check was initiated.
  final BigInt timestampMs;

  /// The high-level status and quality summary of the network connection.
  final NetworkStatus status;

  /// The detected type of the active network connection (e.g., WiFi, Cellular).
  final ConnectionType connectionType;

  /// Security-related flags for the connection (e.g., VPN, DNS spoofing).
  final SecurityFlags securityFlags;

  /// A list of detailed reports for each individual target that was checked.
  final List<TargetReport> targetReports;

  /// The top-level report containing all information from a comprehensive network check.

  const NetworkReport({
    required this.timestampMs,
    required this.status,
    required this.connectionType,
    required this.securityFlags,
    required this.targetReports,
  });

  @override
  int get hashCode =>
      timestampMs.hashCode ^
      status.hashCode ^
      connectionType.hashCode ^
      securityFlags.hashCode ^
      targetReports.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkReport &&
          runtimeType == other.runtimeType &&
          timestampMs == other.timestampMs &&
          status == other.status &&
          connectionType == other.connectionType &&
          securityFlags == other.securityFlags &&
          targetReports == other.targetReports;
}

/// A high-level summary of the network state at a given time.
class NetworkStatus {
  /// True if a connection to any target was successfully established.
  final bool isConnected;

  /// The overall calculated quality of the connection.
  final ConnectionQuality quality;

  /// Detailed statistics about latency and stability.
  final LatencyStats latencyStats;

  /// The label of the target that responded fastest in the final sample.
  final String winnerTarget;

  /// A high-level summary of the network state at a given time.

  const NetworkStatus({
    required this.isConnected,
    required this.quality,
    required this.latencyStats,
    required this.winnerTarget,
  });

  @override
  int get hashCode =>
      isConnected.hashCode ^
      quality.hashCode ^
      latencyStats.hashCode ^
      winnerTarget.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkStatus &&
          runtimeType == other.runtimeType &&
          isConnected == other.isConnected &&
          quality == other.quality &&
          latencyStats == other.latencyStats &&
          winnerTarget == other.winnerTarget;
}

/// The result of a check against a single network target.
class TargetReport {
  /// The unique label for the target.
  final String label;

  /// True if the check was successful.
  final bool success;

  /// The latency of the successful check in milliseconds.
  final BigInt latencyMs;

  /// An error message if the check failed.
  final String? error;

  /// Whether this target is considered essential for the overall check.
  final bool isEssential;

  /// The result of a check against a single network target.

  const TargetReport({
    required this.label,
    required this.success,
    required this.latencyMs,
    this.error,
    required this.isEssential,
  });

  @override
  int get hashCode =>
      label.hashCode ^
      success.hashCode ^
      latencyMs.hashCode ^
      error.hashCode ^
      isEssential.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TargetReport &&
          runtimeType == other.runtimeType &&
          label == other.label &&
          success == other.success &&
          latencyMs == other.latencyMs &&
          error == other.error &&
          isEssential == other.isEssential;
}
