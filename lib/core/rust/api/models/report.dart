// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'config.dart';
import 'net_info.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// The top-level report containing all information about a network check.
class NetworkReport {
  /// The timestamp (in milliseconds since epoch) when the check was initiated.
  final BigInt timestampMs;

  /// The detailed status of the network connection.
  final NetworkStatus status;

  /// The detected type of the active network connection (WiFi, Cellular, etc.).
  final ConnectionType connectionType;

  /// Security-related flags for the connection.
  final SecurityFlags securityFlags;

  /// A list of reports for each individual target that was checked.
  final List<TargetReport> targetReports;

  const NetworkReport({
    required this.timestampMs,
    required this.status,
    required this.connectionType,
    required this.securityFlags,
    required this.targetReports,
  });

  @override
  int get hashCode =>
      timestampMs.hashCode ^
      status.hashCode ^
      connectionType.hashCode ^
      securityFlags.hashCode ^
      targetReports.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkReport &&
          runtimeType == other.runtimeType &&
          timestampMs == other.timestampMs &&
          status == other.status &&
          connectionType == other.connectionType &&
          securityFlags == other.securityFlags &&
          targetReports == other.targetReports;
}

/// A comprehensive snapshot of the network state at a given time.
class NetworkStatus {
  /// The final, overall result: true if the network is usable.
  final bool isConnected;

  /// The evaluated quality of the connection (Excellent, Good, Poor, etc.).
  final ConnectionQuality quality;

  /// The mean latency in milliseconds from the winning target(s).
  final BigInt latencyMs;

  /// The standard deviation of latency in milliseconds, indicating stability.
  final BigInt jitterMs;

  /// The percentage of packets lost during the check (future implementation).
  final double packetLossPercent;

  /// The label of the target that responded first in a 'Race' strategy.
  final String winnerTarget;

  /// Minimum latency recorded during jitter analysis.
  final BigInt? minLatencyMs;

  /// Maximum latency recorded during jitter analysis.
  final BigInt? maxLatencyMs;

  const NetworkStatus({
    required this.isConnected,
    required this.quality,
    required this.latencyMs,
    required this.jitterMs,
    required this.packetLossPercent,
    required this.winnerTarget,
    this.minLatencyMs,
    this.maxLatencyMs,
  });

  @override
  int get hashCode =>
      isConnected.hashCode ^
      quality.hashCode ^
      latencyMs.hashCode ^
      jitterMs.hashCode ^
      packetLossPercent.hashCode ^
      winnerTarget.hashCode ^
      minLatencyMs.hashCode ^
      maxLatencyMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkStatus &&
          runtimeType == other.runtimeType &&
          isConnected == other.isConnected &&
          quality == other.quality &&
          latencyMs == other.latencyMs &&
          jitterMs == other.jitterMs &&
          packetLossPercent == other.packetLossPercent &&
          winnerTarget == other.winnerTarget &&
          minLatencyMs == other.minLatencyMs &&
          maxLatencyMs == other.maxLatencyMs;
}

class TargetReport {
  final String label;
  final bool success;
  final BigInt? latencyMs;
  final String? error;
  final bool isEssential;

  const TargetReport({
    required this.label,
    required this.success,
    this.latencyMs,
    this.error,
    required this.isEssential,
  });

  @override
  int get hashCode =>
      label.hashCode ^
      success.hashCode ^
      latencyMs.hashCode ^
      error.hashCode ^
      isEssential.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TargetReport &&
          runtimeType == other.runtimeType &&
          label == other.label &&
          success == other.success &&
          latencyMs == other.latencyMs &&
          error == other.error &&
          isEssential == other.isEssential;
}
