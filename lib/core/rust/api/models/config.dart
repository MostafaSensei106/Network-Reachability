// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'target.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Defines the strategy for evaluating multiple targets.
enum CheckStrategy {
  /// The first target to respond successfully determines the result.
  /// This is faster but less reliable.
  race,

  /// A majority of targets must respond successfully for the check to be
  /// considered a success. This is slower but more robust.
  consensus,
  ;
}

/// Represents the perceived quality of the network connection.
enum ConnectionQuality {
  /// Excellent connection, very low latency. Suitable for all tasks.
  excellent,

  /// Great connection, low latency. Suitable for most tasks.
  great,

  /// Good, usable connection.
  good,

  /// Moderate connection, noticeable latency. May affect real-time applications.
  moderate,

  /// Poor connection, high latency. Basic browsing may be slow.
  poor,

  /// Connection is active, but packet loss or high jitter makes it unreliable.
  unstable,

  /// No connection detected or all essential targets failed.
  offline,
  ;
}

/// The main configuration for the network reachability engine.
class NetworkConfiguration {
  /// A list of network endpoints to check.
  final List<NetworkTarget> targets;

  /// The time in milliseconds between automatic periodic checks.
  /// A value of 0 disables periodic checks.
  final BigInt checkIntervalMs;

  /// Latency thresholds for determining connection quality.
  final QualityThresholds qualityThreshold;

  /// Security-related settings.
  final SecurityConfig security;

  /// Resilience and performance tuning settings.
  final ResilienceConfig resilience;

  const NetworkConfiguration({
    required this.targets,
    required this.checkIntervalMs,
    required this.qualityThreshold,
    required this.security,
    required this.resilience,
  });

  /// Creates a default configuration with checks against Cloudflare and Google DNS.
  static Future<NetworkConfiguration> default_() =>
      RustLib.instance.api.crateApiModelsConfigNetworkConfigurationDefault();

  @override
  int get hashCode =>
      targets.hashCode ^
      checkIntervalMs.hashCode ^
      qualityThreshold.hashCode ^
      security.hashCode ^
      resilience.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkConfiguration &&
          runtimeType == other.runtimeType &&
          targets == other.targets &&
          checkIntervalMs == other.checkIntervalMs &&
          qualityThreshold == other.qualityThreshold &&
          security == other.security &&
          resilience == other.resilience;
}

/// Defines the latency thresholds (in milliseconds) used to determine [ConnectionQuality].
class QualityThresholds {
  /// Latency at or below this value is 'Excellent'.
  final BigInt excellent;

  /// Latency at or below this value is 'Great'.
  final BigInt great;

  /// Latency at or below this value is 'Good'.
  final BigInt good;

  /// Latency at or below this value is 'Moderate'.
  final BigInt moderate;

  /// Latency at or below this value is 'Poor'. Anything higher is 'Unstable'.
  final BigInt poor;

  const QualityThresholds({
    required this.excellent,
    required this.great,
    required this.good,
    required this.moderate,
    required this.poor,
  });

  static Future<QualityThresholds> default_() =>
      RustLib.instance.api.crateApiModelsConfigQualityThresholdsDefault();

  @override
  int get hashCode =>
      excellent.hashCode ^
      great.hashCode ^
      good.hashCode ^
      moderate.hashCode ^
      poor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QualityThresholds &&
          runtimeType == other.runtimeType &&
          excellent == other.excellent &&
          great == other.great &&
          good == other.good &&
          moderate == other.moderate &&
          poor == other.poor;
}

/// Configuration for resilience and performance tuning.
class ResilienceConfig {
  /// The strategy to use for checking multiple targets.
  final CheckStrategy strategy;

  /// The number of consecutive failures of essential targets before the
  /// circuit breaker opens. A value of 0 disables the circuit breaker.
  final int circuitBreakerThreshold;

  /// Number of samples to take for jitter and stability analysis.
  /// Must be greater than 1 to enable jitter calculation.
  final int numJitterSamples;

  /// The percentage of mean latency that the standard deviation must exceed
  /// to be considered high jitter, potentially downgrading quality.
  final double jitterThresholdPercent;

  /// If the calculated stability score is less than this value, the quality
  /// may be downgraded.
  final int stabilityThershold;

  /// The packet loss percentage above which the connection is marked as 'Unstable'.
  final double criticalPacketLossPrecent;

  const ResilienceConfig({
    required this.strategy,
    required this.circuitBreakerThreshold,
    required this.numJitterSamples,
    required this.jitterThresholdPercent,
    required this.stabilityThershold,
    required this.criticalPacketLossPrecent,
  });

  static Future<ResilienceConfig> default_() =>
      RustLib.instance.api.crateApiModelsConfigResilienceConfigDefault();

  @override
  int get hashCode =>
      strategy.hashCode ^
      circuitBreakerThreshold.hashCode ^
      numJitterSamples.hashCode ^
      jitterThresholdPercent.hashCode ^
      stabilityThershold.hashCode ^
      criticalPacketLossPrecent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ResilienceConfig &&
          runtimeType == other.runtimeType &&
          strategy == other.strategy &&
          circuitBreakerThreshold == other.circuitBreakerThreshold &&
          numJitterSamples == other.numJitterSamples &&
          jitterThresholdPercent == other.jitterThresholdPercent &&
          stabilityThershold == other.stabilityThershold &&
          criticalPacketLossPrecent == other.criticalPacketLossPrecent;
}

/// Configuration for security-related checks.
class SecurityConfig {
  /// If true, the `guard` function will throw an exception if a VPN is detected.
  final bool blockVpn;

  /// If true, performs a check to detect potential DNS hijacking.
  /// This adds a small latency to each check.
  final bool detectDnsHijack;

  /// A list of allowed interface name prefixes (e.g., "en", "wlan").
  /// If not empty, the `guard` will fail if the active interface
  /// does not match one of the prefixes.
  final List<String> allowedInterfaces;

  const SecurityConfig({
    required this.blockVpn,
    required this.detectDnsHijack,
    required this.allowedInterfaces,
  });

  static Future<SecurityConfig> default_() =>
      RustLib.instance.api.crateApiModelsConfigSecurityConfigDefault();

  @override
  int get hashCode =>
      blockVpn.hashCode ^ detectDnsHijack.hashCode ^ allowedInterfaces.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecurityConfig &&
          runtimeType == other.runtimeType &&
          blockVpn == other.blockVpn &&
          detectDnsHijack == other.detectDnsHijack &&
          allowedInterfaces == other.allowedInterfaces;
}
