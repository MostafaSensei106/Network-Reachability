// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'target.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

enum CheckStrategy {
  /// The first target to respond successfully determines the result.
  race,

  /// A majority of targets must respond successfully.
  consensus,
  ;
}

enum ConnectionQuality {
  excellent,
  great,
  good,
  moderate,
  poor,

  /// Connection is active but latency is highly variable.
  unstable,

  /// No connection.
  dead,
  ;
}

/// The main configuration for the network reachability engine.
class NetworkConfiguration {
  /// The list of targets to check.
  final List<NetworkTarget> targets;

  /// The time between automatic checks. 0 to disable.
  final BigInt checkIntervalMs;

  /// Latency thresholds for determining connection quality.
  final QualityThresholds qualityThreshold;

  /// Security-related settings.
  final SecurityConfig security;

  /// Resilience and performance settings.
  final ResilienceConfig resilience;

  const NetworkConfiguration({
    required this.targets,
    required this.checkIntervalMs,
    required this.qualityThreshold,
    required this.security,
    required this.resilience,
  });

  static Future<NetworkConfiguration> default_() =>
      RustLib.instance.api.crateApiModelsConfigNetworkConfigurationDefault();

  @override
  int get hashCode =>
      targets.hashCode ^
      checkIntervalMs.hashCode ^
      qualityThreshold.hashCode ^
      security.hashCode ^
      resilience.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkConfiguration &&
          runtimeType == other.runtimeType &&
          targets == other.targets &&
          checkIntervalMs == other.checkIntervalMs &&
          qualityThreshold == other.qualityThreshold &&
          security == other.security &&
          resilience == other.resilience;
}

class QualityThresholds {
  final BigInt excellent;
  final BigInt great;
  final BigInt good;
  final BigInt moderate;
  final BigInt poor;

  const QualityThresholds({
    required this.excellent,
    required this.great,
    required this.good,
    required this.moderate,
    required this.poor,
  });

  static Future<QualityThresholds> default_() =>
      RustLib.instance.api.crateApiModelsConfigQualityThresholdsDefault();

  @override
  int get hashCode =>
      excellent.hashCode ^
      great.hashCode ^
      good.hashCode ^
      moderate.hashCode ^
      poor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QualityThresholds &&
          runtimeType == other.runtimeType &&
          excellent == other.excellent &&
          great == other.great &&
          good == other.good &&
          moderate == other.moderate &&
          poor == other.poor;
}

/// Configuration for resilience and performance features.
class ResilienceConfig {
  /// The strategy to use for checking multiple targets.
  final CheckStrategy strategy;

  /// The number of consecutive failures before the circuit breaker opens. 0 to disable.
  final int circuitBreakerThreshold;

  /// Number of samples for jitter analysis. Must be > 1 to enable jitter check.
  final int numJitterSamples;

  /// The percentage of mean latency that the standard deviation must exceed to be marked as 'Unstable'.
  final double jitterThresholdPercent;

  const ResilienceConfig({
    required this.strategy,
    required this.circuitBreakerThreshold,
    required this.numJitterSamples,
    required this.jitterThresholdPercent,
  });

  static Future<ResilienceConfig> default_() =>
      RustLib.instance.api.crateApiModelsConfigResilienceConfigDefault();

  @override
  int get hashCode =>
      strategy.hashCode ^
      circuitBreakerThreshold.hashCode ^
      numJitterSamples.hashCode ^
      jitterThresholdPercent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ResilienceConfig &&
          runtimeType == other.runtimeType &&
          strategy == other.strategy &&
          circuitBreakerThreshold == other.circuitBreakerThreshold &&
          numJitterSamples == other.numJitterSamples &&
          jitterThresholdPercent == other.jitterThresholdPercent;
}

/// Configuration for security-related checks.
class SecurityConfig {
  /// If true, the check will fail if a VPN is detected.
  final bool blockVpn;

  /// If true, performs a check to detect potential DNS hijacking.
  final bool detectDnsHijack;

  /// A list of allowed interface prefixes. If not empty, the check will fail if the active interface is not on this list.
  final List<String> allowedInterfaces;

  const SecurityConfig({
    required this.blockVpn,
    required this.detectDnsHijack,
    required this.allowedInterfaces,
  });

  static Future<SecurityConfig> default_() =>
      RustLib.instance.api.crateApiModelsConfigSecurityConfigDefault();

  @override
  int get hashCode =>
      blockVpn.hashCode ^ detectDnsHijack.hashCode ^ allowedInterfaces.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecurityConfig &&
          runtimeType == other.runtimeType &&
          blockVpn == other.blockVpn &&
          detectDnsHijack == other.detectDnsHijack &&
          allowedInterfaces == other.allowedInterfaces;
}
