import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:network_reachability/network_reachability.dart';

// This file is generated by `flutter_rust_bridge_codegen`.
// It's the bridge between your Flutter app and the Rust core.
// Ensure you have run the code generation tool before running this example.

Future<void> main() async {
  // --- Step 1: Initialization ---
  // This is a mandatory setup sequence for any Flutter app using this library.

  // Ensures that Flutter's widget bindings are ready before any Flutter-specific
  // code is executed.
  WidgetsFlutterBinding.ensureInitialized();

  // Initializes the native Rust library bindings. This must be called before
  // any function from the Rust core can be used.
  await RustLib.init();

  // Initializes the NetworkReachability singleton. You can pass a custom
  // configuration here, but for this example, we'll use the default.
  // The default configuration checks against reliable public DNS servers.
  final config = NetworkConfiguration.default_();

  await NetworkReachability.init(config: await config);

  // Run the Flutter application.
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Network Reachability Demo',
      theme: ThemeData.dark(useMaterial3: true).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.cyan,
          brightness: Brightness.dark,
        ),
      ),
      home: const NetworkDemoPage(),
    );
  }
}

class NetworkDemoPage extends StatefulWidget {
  const NetworkDemoPage({super.key});

  @override
  State<NetworkDemoPage> createState() => _NetworkDemoPageState();
}

class _NetworkDemoPageState extends State<NetworkDemoPage> {
  // --- State Management ---

  // Holds the latest full network report from a check.
  NetworkReport? _report;

  // Manages the subscription to the periodic network status updates.
  StreamSubscription? _statusSubscription;

  // Tracks loading state to show progress indicators in the UI.
  bool _isLoading = true;

  // Stores the result or error message from the `guard()` demo.
  String _guardResult = 'Press the button above to test the "guard" feature.';

  @override
  void initState() {
    super.initState();

    // --- Initial Check and Subscription ---

    // Perform an initial check as soon as the widget is created to populate the UI.
    _manualCheck();

    // Subscribe to the `onStatusChange` stream. This stream emits a new `NetworkStatus`
    // at the interval defined in your `NetworkConfiguration` (default is 5 seconds).
    // This is useful for passively monitoring the network in the background.
    _statusSubscription = NetworkReachability.instance.onStatusChange.listen((
      status,
    ) {
      // When a change is detected, we run a full manual check to update
      // our UI with the complete `NetworkReport`, not just the `NetworkStatus`.
      if (kDebugMode) {
        print('Network status changed, running a full check.');
      }
      _manualCheck();
    });
  }

  @override
  void dispose() {
    // --- Cleanup ---
    // It's crucial to cancel stream subscriptions in the dispose method
    // to prevent memory leaks when the widget is removed from the tree.
    _statusSubscription?.cancel();
    super.dispose();
  }

  /// --- Core Logic Methods ---

  /// Performs a full, on-demand network check and updates the UI.
  Future<void> _manualCheck() async {
    if (!mounted) return;
    setState(() => _isLoading = true);

    if (kDebugMode) {
      print('Performing manual network check...');
    }
    final report = await NetworkReachability.instance.check();
    if (kDebugMode) {
      print('Check complete. Quality: ${report.status.quality.name}');
    }

    // Check if the widget is still in the widget tree before updating state.
    if (!mounted) return;
    setState(() {
      _report = report;
      _isLoading = false;
    });
  }

  /// Demonstrates the `guard()` method to protect a simulated network call.
  Future<void> _performGuardedAction() async {
    setState(() => _guardResult = 'Checking network and performing action...');

    try {
      // The `guard` method is the core of the library's resilience pattern.
      // It first runs a fresh network check. If the checks pass against the
      // configured rules (and the optional `minQuality`), it executes `action`.
      // Otherwise, it throws a specific exception.
      final result = await NetworkReachability.instance.guard(
        action: () async {
          // This is your critical code, e.g., an API call to fetch data.
          // We simulate a 1-second network delay here.
          await Future.delayed(const Duration(seconds: 1));
          return "Action Succeeded at ${DateTime.now().toIso8601String()}";
        },
        // For this action, we require the connection to be at least 'moderate'.
        // If the connection is 'poor' or 'unstable', it will fail early.
        minQuality: ConnectionQuality.moderate,
      );
      setState(() => _guardResult = result);
    } on NetworkReachabilityException catch (e) {
      // Catching specific exceptions from the library allows for tailored
      // user feedback instead of a generic "An error occurred."
      setState(() {
        _guardResult = 'Action Failed!\n${e.runtimeType}: ${e.message}';
      });
    } catch (e) {
      // Catch any other unexpected errors.
      setState(() => _guardResult = 'An unexpected error occurred: $e');
    }
  }

  /// --- UI Build Method ---

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Network Reachability'),
        scrolledUnderElevation: 0,
        elevation: 0.0,
        backgroundColor: Colors.transparent,
        actions: [
          // Show a loading indicator in the app bar if a check is in progress.
          if (_isLoading)
            const Padding(
              padding: EdgeInsets.only(right: 16),
              child: SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
            ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: _manualCheck,
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children: [
            // --- Guard Demo Section ---
            Text('Guard Feature Demo', style: textTheme.titleLarge),
            const SizedBox(height: 8),
            Text(
              'This button simulates a critical network request protected by the `guard()` method. It will only succeed if the network quality is at least "moderate".',
              style: textTheme.bodySmall,
            ),
            const SizedBox(height: 12),
            ElevatedButton(
              onPressed: _performGuardedAction,
              child: const Text('Perform Guarded Action'),
            ),
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.black26,
                borderRadius: BorderRadius.circular(8),
              ),
              width: double.infinity,
              child: Text(_guardResult, textAlign: TextAlign.center),
            ),
            const Divider(height: 32),

            // --- Full Report Section ---
            if (_report != null)
              _NetworkReportView(report: _report!)
            else if (_isLoading)
              const Center(child: Text("Performing initial network check..."))
            else
              const Center(
                child: Text("Failed to get initial network report."),
              ),

            const SizedBox(height: 80),
          ],
        ),
      ),
      // A floating action button to trigger a manual check at any time.
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _manualCheck,
        label: const Text('Manual Check'),
        icon: const Icon(Icons.refresh),
      ),
    );
  }
}

/// A helper widget to display the detailed network report.
class _NetworkReportView extends StatelessWidget {
  final NetworkReport report;

  const _NetworkReportView({required this.report});

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final status = report.status;
    final qualityColor = _getQualityColor(status.quality);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Live Network Report', style: textTheme.titleLarge),
        const SizedBox(height: 16),

        // --- Quality Summary ---
        _buildSection(
          title: 'Quality Summary',
          children: [
            _buildInfoRow(
              'Connected:',
              status.isConnected ? 'Yes' : 'No',
              status.isConnected ? Colors.greenAccent : Colors.red,
            ),
            _buildInfoRow(
              'Overall Quality:',
              status.quality.name,
              qualityColor,
            ),
            _buildInfoRow(
              'Winning Target:',
              status.winnerTarget.isEmpty ? 'N/A' : status.winnerTarget,
            ),
          ],
        ),

        // --- Latency & Stability ---
        _buildSection(
          title: 'Latency & Stability',
          children: [
            _buildInfoRow(
              'Stability Score:',
              '${status.latencyStats.stabilityScore}/100',
            ),
            _buildInfoRow(
              'Average Latency:',
              '${status.latencyStats.avgLatencyMs ?? 'N/A'} ms',
            ),
            _buildInfoRow('Max Latency','${status.latencyStats.maxLatencyMs ?? 'N/A'} ms',
            ),
            _buildInfoRow('Min Latency','${status.latencyStats.minLatencyMs ?? 'N/A'} ms',
            ),
            _buildInfoRow('Jitter:', '${status.latencyStats.jitterMs} ms'),
            _buildInfoRow(
              'Packet Loss:',
              '${status.latencyStats.packetLossPercent}%',
            ),

          ],
        ),

        // --- Security Details ---
        _buildSection(
          title: 'Security & Interface',
          children: [
            _buildInfoRow('Connection Type:', report.connectionType.name),
            _buildInfoRow(
              'Interface Name:',
              report.securityFlags.interfaceName,
            ),
            _buildInfoRow(
              'VPN Detected:',
              report.securityFlags.isVpnDetected ? 'Yes' : 'No',
              report.securityFlags.isVpnDetected ? Colors.orangeAccent : null,
            ),
            _buildInfoRow(
              'DNS Spoofed:',
              report.securityFlags.isDnsSpoofed ? 'Yes' : 'No',
              report.securityFlags.isDnsSpoofed ? Colors.redAccent : null,
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildSection({
    required String title,
    required List<Widget> children,
  }) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const Divider(height: 12),
            ...children,
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value, [Color? valueColor]) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(color: Colors.white70)),
          Text(
            value,
            style: TextStyle(fontWeight: FontWeight.bold, color: valueColor),
          ),
        ],
      ),
    );
  }

  Color _getQualityColor(ConnectionQuality quality) {
    switch (quality) {
      case ConnectionQuality.excellent:
        return Colors.greenAccent;
      case ConnectionQuality.great:
        return Colors.lightGreen;
      case ConnectionQuality.good:
        return Colors.yellow;
      case ConnectionQuality.moderate:
        return Colors.orange;
      case ConnectionQuality.poor:
        return Colors.red;
      case ConnectionQuality.unstable:
        return Colors.purpleAccent;
      case ConnectionQuality.offline:
        return Colors.grey;
    }
  }
}
